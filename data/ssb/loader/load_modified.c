/* This file is generated by code_gen.py */
#define _FILE_OFFSET_BITS       64
#define _LARGEFILE_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <error.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <linux/limits.h>
#include "include/schema.h"
#include "include/common.h"

#define CHECK_POINTER(p) do {\
  if(p == NULL){   \
    perror("Failed to allocate host memory");    \
    exit(-1);  \
  }} while(0)

static char delimiter = '|';

void supplier (FILE *fp, char *outName){
  struct supplier tmp;
  char data [1024] = {0};
  char buf[1024] = {0};
  int count = 0, i = 0,prev = 0;
  long tupleCount =0, tupleRemain = 0, tupleUnit = 0;
  FILE * out[7];

  for(i=0;i<7;i++){
    char path[PATH_MAX] = {0};
    sprintf(path,"%s%d",outName,i);
    out[i] = fopen(path, "w");
    if(!out[i]){
      printf("Failed to open %s\n",path);
      exit(-1);
    }
  }

  struct columnHeader header;
  long tupleNum = 0;
  while(fgets(buf,sizeof(buf),fp) !=NULL)
    tupleNum ++;

  header.totalTupleNum = tupleNum;
  tupleRemain = tupleNum;
  if(tupleNum > BLOCKNUM)
    tupleUnit = BLOCKNUM;
  else
    tupleUnit = tupleNum;
  header.tupleNum = tupleUnit;
  header.format = UNCOMPRESSED;
  header.blockId = 0;
  header.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;
  fseek(fp,0,SEEK_SET);
/*  header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[0]);*/
  /*header.blockSize = header.tupleNum * 25;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[1]);*/
  /*header.blockSize = header.tupleNum * 25;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[2]);*/
  /*header.blockSize = header.tupleNum * 10;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[3]);*/
  /*header.blockSize = header.tupleNum * 15;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[4]);*/
  /*header.blockSize = header.tupleNum * 12;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[5]);*/
  /*header.blockSize = header.tupleNum * 15;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[6]);*/
  while(fgets(buf,sizeof(buf),fp)!= NULL){
    int writeHeader = 0;
    tupleCount ++;
    if(tupleCount > BLOCKNUM){
      tupleCount = 1;
      tupleRemain -= BLOCKNUM;
      if (tupleRemain > BLOCKNUM)
        tupleUnit = BLOCKNUM;
      else
        tupleUnit = tupleRemain;
      header.tupleNum = tupleUnit;
      header.blockId ++;
      writeHeader = 1;
    }
    for(i = 0, prev = 0,count=0; buf[i] !='\n';i++){
      if (buf[i] == delimiter){
        memset(data,0,sizeof(data));
        strncpy(data,buf+prev,i-prev);
        prev = i+1;
        switch(count){
           case 0:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[0]);
            }
            tmp.s_suppkey = strtol(data,NULL,10);
            fwrite(&(tmp.s_suppkey),sizeof(int),1,out[0]);
            break;
           case 1:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 25;
              fwrite(&header,sizeof(struct columnHeader),1,out[1]);
            }
            strcpy(tmp.s_name,data);
            fwrite(&(tmp.s_name),sizeof(tmp.s_name), 1, out[1]);
            break;
           case 2:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 25;
              fwrite(&header,sizeof(struct columnHeader),1,out[2]);
            }
            strcpy(tmp.s_address,data);
            fwrite(&(tmp.s_address),sizeof(tmp.s_address), 1, out[2]);
            break;
           case 3:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 10;
              fwrite(&header,sizeof(struct columnHeader),1,out[3]);
            }
            int s_city = strtol(data, NULL, 10);
            /*strcpy(tmp.s_city,data);*/
            fwrite(&(s_city),sizeof(int), 1, out[3]);
            break;
           case 4:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 15;
              fwrite(&header,sizeof(struct columnHeader),1,out[4]);
            }
            int s_nation = strtol(data, NULL, 10);
            /*strcpy(tmp.s_nation,data);*/
            fwrite(&(s_nation),sizeof(int), 1, out[4]);
            break;
           case 5:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 12;
              fwrite(&header,sizeof(struct columnHeader),1,out[5]);
            }
            int s_region = strtol(data, NULL, 10);
            /*strcpy(tmp.s_region,data);*/
            fwrite(&(s_region),sizeof(int), 1, out[5]);
            break;
           case 6:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 15;
              fwrite(&header,sizeof(struct columnHeader),1,out[6]);
            }
            strcpy(tmp.s_phone,data);
            fwrite(&(tmp.s_phone),sizeof(tmp.s_phone), 1, out[6]);
            break;
        }
        count++;
      }
    }
    if(count == 6){
      if(writeHeader == 1){
        header.blockSize = header.tupleNum * 15;
        fwrite(&header,sizeof(struct columnHeader),1,out[6]);
      }
      strncpy(tmp.s_phone,buf+prev,i-prev);
      fwrite(&(tmp.s_phone),sizeof(tmp.s_phone), 1, out[6]);
    }
  }

  for(i=0;i<7;i++){
    fclose(out[i]);
  }

}

void customer (FILE *fp, char *outName){
  struct customer tmp;
  char data [1024] = {0};
  char buf[1024] = {0};
  int count = 0, i = 0,prev = 0;
  long tupleCount =0, tupleRemain = 0, tupleUnit = 0;
  FILE * out[8];

  for(i=0;i<8;i++){
    char path[PATH_MAX] = {0};
    sprintf(path,"%s%d",outName,i);
    out[i] = fopen(path, "w");
    if(!out[i]){
      printf("Failed to open %s\n",path);
      exit(-1);
    }
  }

  struct columnHeader header;
  long tupleNum = 0;
  while(fgets(buf,sizeof(buf),fp) !=NULL)
    tupleNum ++;

  header.totalTupleNum = tupleNum;
  tupleRemain = tupleNum;
  if(tupleNum > BLOCKNUM)
    tupleUnit = BLOCKNUM;
  else
    tupleUnit = tupleNum;
  header.tupleNum = tupleUnit;
  header.format = UNCOMPRESSED;
  header.blockId = 0;
  header.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;
  fseek(fp,0,SEEK_SET);
/*  header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[0]);*/
  /*header.blockSize = header.tupleNum * 25;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[1]);*/
  /*header.blockSize = header.tupleNum * 25;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[2]);*/
  /*header.blockSize = header.tupleNum * 10;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[3]);*/
  /*header.blockSize = header.tupleNum * 15;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[4]);*/
  /*header.blockSize = header.tupleNum * 12;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[5]);*/
  /*header.blockSize = header.tupleNum * 15;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[6]);*/
  /*header.blockSize = header.tupleNum * 10;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[7]);*/
  while(fgets(buf,sizeof(buf),fp)!= NULL){
    int writeHeader = 0;
    tupleCount ++;
    if(tupleCount > BLOCKNUM){
      tupleCount = 1;
      tupleRemain -= BLOCKNUM;
      if (tupleRemain > BLOCKNUM)
        tupleUnit = BLOCKNUM;
      else
        tupleUnit = tupleRemain;
      header.tupleNum = tupleUnit;
      header.blockId ++;
      writeHeader = 1;
    }
    for(i = 0, prev = 0,count=0; buf[i] !='\n';i++){
      if (buf[i] == delimiter){
        memset(data,0,sizeof(data));
        strncpy(data,buf+prev,i-prev);
        prev = i+1;
        switch(count){
           case 0:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[0]);
            }
            tmp.c_custkey = strtol(data,NULL,10);
            fwrite(&(tmp.c_custkey),sizeof(int),1,out[0]);
            break;
           case 1:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 25;
              fwrite(&header,sizeof(struct columnHeader),1,out[1]);
            }
            strcpy(tmp.c_name,data);
            fwrite(&(tmp.c_name),sizeof(tmp.c_name), 1, out[1]);
            break;
           case 2:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 25;
              fwrite(&header,sizeof(struct columnHeader),1,out[2]);
            }
            strcpy(tmp.c_address,data);
            fwrite(&(tmp.c_address),sizeof(tmp.c_address), 1, out[2]);
            break;
           case 3:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 10;
              fwrite(&header,sizeof(struct columnHeader),1,out[3]);
            }
            int c_city = strtol(data, NULL, 10);
            /*strcpy(tmp.c_city,data);*/
            fwrite(&(c_city),sizeof(int), 1, out[3]);
            break;
           case 4:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 15;
              fwrite(&header,sizeof(struct columnHeader),1,out[4]);
            }
            int c_nation = strtol(data, NULL, 10);
            /*strcpy(tmp.c_nation,data);*/
            fwrite(&(c_nation),sizeof(int), 1, out[4]);
            break;
           case 5:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 12;
              fwrite(&header,sizeof(struct columnHeader),1,out[5]);
            }
            int c_region= strtol(data, NULL, 10);
            /*strcpy(tmp.c_region,data);*/
            fwrite(&(c_region),sizeof(int), 1, out[5]);
            break;
           case 6:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 15;
              fwrite(&header,sizeof(struct columnHeader),1,out[6]);
            }
            strcpy(tmp.c_phone,data);
            fwrite(&(tmp.c_phone),sizeof(tmp.c_phone), 1, out[6]);
            break;
           case 7:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 10;
              fwrite(&header,sizeof(struct columnHeader),1,out[7]);
            }
            strcpy(tmp.c_mktsegment,data);
            fwrite(&(tmp.c_mktsegment),sizeof(tmp.c_mktsegment), 1, out[7]);
            break;
        }
        count++;
      }
    }
    if(count == 7){
      if(writeHeader == 1){
        header.blockSize = header.tupleNum * 10;
        fwrite(&header,sizeof(struct columnHeader),1,out[7]);
      }
      strncpy(tmp.c_mktsegment,buf+prev,i-prev);
      fwrite(&(tmp.c_mktsegment),sizeof(tmp.c_mktsegment), 1, out[7]);
    }
  }

  for(i=0;i<8;i++){
    fclose(out[i]);
  }

}

void part (FILE *fp, char *outName){
  struct part tmp;
  char data [1024] = {0};
  char buf[1024] = {0};
  int count = 0, i = 0,prev = 0;
  long tupleCount =0, tupleRemain = 0, tupleUnit = 0;
  FILE * out[9];

  for(i=0;i<9;i++){
    char path[PATH_MAX] = {0};
    sprintf(path,"%s%d",outName,i);
    out[i] = fopen(path, "w");
    if(!out[i]){
      printf("Failed to open %s\n",path);
      exit(-1);
    }
  }

  struct columnHeader header;
  long tupleNum = 0;
  while(fgets(buf,sizeof(buf),fp) !=NULL)
    tupleNum ++;

  header.totalTupleNum = tupleNum;
  tupleRemain = tupleNum;
  if(tupleNum > BLOCKNUM)
    tupleUnit = BLOCKNUM;
  else
    tupleUnit = tupleNum;
  header.tupleNum = tupleUnit;
  header.format = UNCOMPRESSED;
  header.blockId = 0;
  header.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;
  fseek(fp,0,SEEK_SET);
/*  header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[0]);*/
  /*header.blockSize = header.tupleNum * 22;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[1]);*/
  /*header.blockSize = header.tupleNum * 6;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[2]);*/
  /*header.blockSize = header.tupleNum * 7;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[3]);*/
  /*header.blockSize = header.tupleNum * 9;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[4]);*/
  /*header.blockSize = header.tupleNum * 11;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[5]);*/
  /*header.blockSize = header.tupleNum * 25;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[6]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[7]);*/
  /*header.blockSize = header.tupleNum * 10;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[8]);*/
  while(fgets(buf,sizeof(buf),fp)!= NULL){
    int writeHeader = 0;
    tupleCount ++;
    if(tupleCount > BLOCKNUM){
      tupleCount = 1;
      tupleRemain -= BLOCKNUM;
      if (tupleRemain > BLOCKNUM)
        tupleUnit = BLOCKNUM;
      else
        tupleUnit = tupleRemain;
      header.tupleNum = tupleUnit;
      header.blockId ++;
      writeHeader = 1;
    }
    for(i = 0, prev = 0,count=0; buf[i] !='\n';i++){
      if (buf[i] == delimiter){
        memset(data,0,sizeof(data));
        strncpy(data,buf+prev,i-prev);
        prev = i+1;
        switch(count){
           case 0:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[0]);
            }
            tmp.p_partkey = strtol(data,NULL,10);
            fwrite(&(tmp.p_partkey),sizeof(int),1,out[0]);
            break;
           case 1:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 22;
              fwrite(&header,sizeof(struct columnHeader),1,out[1]);
            }
            strcpy(tmp.p_name,data);
            fwrite(&(tmp.p_name),sizeof(tmp.p_name), 1, out[1]);
            break;
           case 2:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 6;
              fwrite(&header,sizeof(struct columnHeader),1,out[2]);
            }
            int p_mfgr = strtol(data, NULL, 10);
            /*strcpy(tmp.p_mfgr,data);*/
            fwrite(&(p_mfgr),sizeof(int), 1, out[2]);
            break;
           case 3:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 7;
              fwrite(&header,sizeof(struct columnHeader),1,out[3]);
            }
            int p_category = strtol(data, NULL, 10);
            /*strcpy(tmp.p_category,data);*/
            fwrite(&(p_category),sizeof(int), 1, out[3]);
            break;
           case 4:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 9;
              fwrite(&header,sizeof(struct columnHeader),1,out[4]);
            }
            int p_brand1 = strtol(data, NULL, 10);
            /*strcpy(tmp.p_brand1,data);*/
            fwrite(&(p_brand1),sizeof(int), 1, out[4]);
            break;
           case 5:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 11;
              fwrite(&header,sizeof(struct columnHeader),1,out[5]);
            }
            strcpy(tmp.p_color,data);
            fwrite(&(tmp.p_color),sizeof(tmp.p_color), 1, out[5]);
            break;
           case 6:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 25;
              fwrite(&header,sizeof(struct columnHeader),1,out[6]);
            }
            strcpy(tmp.p_type,data);
            fwrite(&(tmp.p_type),sizeof(tmp.p_type), 1, out[6]);
            break;
           case 7:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[7]);
            }
            tmp.p_size = strtol(data,NULL,10);
            fwrite(&(tmp.p_size),sizeof(int),1,out[7]);
            break;
           case 8:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 10;
              fwrite(&header,sizeof(struct columnHeader),1,out[8]);
            }
            strcpy(tmp.p_container,data);
            fwrite(&(tmp.p_container),sizeof(tmp.p_container), 1, out[8]);
            break;
        }
        count++;
      }
    }
    if(count == 8){
      if(writeHeader == 1){
        header.blockSize = header.tupleNum * 10;
        fwrite(&header,sizeof(struct columnHeader),1,out[8]);
      }
      strncpy(tmp.p_container,buf+prev,i-prev);
      fwrite(&(tmp.p_container),sizeof(tmp.p_container), 1, out[8]);
    }
  }

  for(i=0;i<9;i++){
    fclose(out[i]);
  }

}

void ddate (FILE *fp, char *outName){
  struct ddate tmp;
  char data [1024] = {0};
  char buf[1024] = {0};
  int count = 0, i = 0,prev = 0;
  long tupleCount =0, tupleRemain = 0, tupleUnit = 0;
  FILE * out[17];

  for(i=0;i<17;i++){
    char path[PATH_MAX] = {0};
    sprintf(path,"%s%d",outName,i);
    out[i] = fopen(path, "w");
    if(!out[i]){
      printf("Failed to open %s\n",path);
      exit(-1);
    }
  }

  struct columnHeader header;
  long tupleNum = 0;
  while(fgets(buf,sizeof(buf),fp) !=NULL)
    tupleNum ++;

  header.totalTupleNum = tupleNum;
  tupleRemain = tupleNum;
  if(tupleNum > BLOCKNUM)
    tupleUnit = BLOCKNUM;
  else
    tupleUnit = tupleNum;
  header.tupleNum = tupleUnit;
  header.format = UNCOMPRESSED;
  header.blockId = 0;
  header.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;
  fseek(fp,0,SEEK_SET);
/*  header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[0]);*/
  /*header.blockSize = header.tupleNum * 18;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[1]);*/
  /*header.blockSize = header.tupleNum * 8;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[2]);*/
  /*header.blockSize = header.tupleNum * 9;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[3]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[4]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[5]);*/
  /*header.blockSize = header.tupleNum * 7;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[6]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[7]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[8]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[9]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[10]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[11]);*/
  /*header.blockSize = header.tupleNum * 12;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[12]);*/
  /*header.blockSize = header.tupleNum * 1;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[13]);*/
  /*header.blockSize = header.tupleNum * 1;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[14]);*/
  /*header.blockSize = header.tupleNum * 1;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[15]);*/
  /*header.blockSize = header.tupleNum * 1;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[16]);*/
  while(fgets(buf,sizeof(buf),fp)!= NULL){
    int writeHeader = 0;
    tupleCount ++;
    if(tupleCount > BLOCKNUM){
      tupleCount = 1;
      tupleRemain -= BLOCKNUM;
      if (tupleRemain > BLOCKNUM)
        tupleUnit = BLOCKNUM;
      else
        tupleUnit = tupleRemain;
      header.tupleNum = tupleUnit;
      header.blockId ++;
      writeHeader = 1;
    }
    for(i = 0, prev = 0,count=0; buf[i] !='\n';i++){
      if (buf[i] == delimiter){
        memset(data,0,sizeof(data));
        strncpy(data,buf+prev,i-prev);
        prev = i+1;
        switch(count){
           case 0:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[0]);
            }
            tmp.d_datekey = strtol(data,NULL,10);
            fwrite(&(tmp.d_datekey),sizeof(int),1,out[0]);
            break;
           case 1:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 18;
              fwrite(&header,sizeof(struct columnHeader),1,out[1]);
            }
            strcpy(tmp.d_date,data);
            fwrite(&(tmp.d_date),sizeof(tmp.d_date), 1, out[1]);
            break;
           case 2:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 8;
              fwrite(&header,sizeof(struct columnHeader),1,out[2]);
            }
            strcpy(tmp.d_dayofweek,data);
            fwrite(&(tmp.d_dayofweek),sizeof(tmp.d_dayofweek), 1, out[2]);
            break;
           case 3:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 9;
              fwrite(&header,sizeof(struct columnHeader),1,out[3]);
            }
            strcpy(tmp.d_month,data);
            fwrite(&(tmp.d_month),sizeof(tmp.d_month), 1, out[3]);
            break;
           case 4:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[4]);
            }
            tmp.d_year = strtol(data,NULL,10);
            fwrite(&(tmp.d_year),sizeof(int),1,out[4]);
            break;
           case 5:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[5]);
            }
            tmp.d_yearmonthnum = strtol(data,NULL,10);
            fwrite(&(tmp.d_yearmonthnum),sizeof(int),1,out[5]);
            break;
           case 6:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 7;
              fwrite(&header,sizeof(struct columnHeader),1,out[6]);
            }
            strcpy(tmp.d_yearmonth,data);
            fwrite(&(tmp.d_yearmonth),sizeof(tmp.d_yearmonth), 1, out[6]);
            break;
           case 7:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[7]);
            }
            tmp.d_daynuminweek = strtol(data,NULL,10);
            fwrite(&(tmp.d_daynuminweek),sizeof(int),1,out[7]);
            break;
           case 8:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[8]);
            }
            tmp.d_daynuminmonth = strtol(data,NULL,10);
            fwrite(&(tmp.d_daynuminmonth),sizeof(int),1,out[8]);
            break;
           case 9:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[9]);
            }
            tmp.d_daynuminyear = strtol(data,NULL,10);
            fwrite(&(tmp.d_daynuminyear),sizeof(int),1,out[9]);
            break;
           case 10:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[10]);
            }
            tmp.d_monthnuminyear = strtol(data,NULL,10);
            fwrite(&(tmp.d_monthnuminyear),sizeof(int),1,out[10]);
            break;
           case 11:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[11]);
            }
            tmp.d_weeknuminyear = strtol(data,NULL,10);
            fwrite(&(tmp.d_weeknuminyear),sizeof(int),1,out[11]);
            break;
           case 12:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 12;
              fwrite(&header,sizeof(struct columnHeader),1,out[12]);
            }
            strcpy(tmp.d_sellingseason,data);
            fwrite(&(tmp.d_sellingseason),sizeof(tmp.d_sellingseason), 1, out[12]);
            break;
           case 13:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 1;
              fwrite(&header,sizeof(struct columnHeader),1,out[13]);
            }
            strcpy(tmp.d_lastdayinweekfl,data);
            fwrite(&(tmp.d_lastdayinweekfl),sizeof(tmp.d_lastdayinweekfl), 1, out[13]);
            break;
           case 14:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 1;
              fwrite(&header,sizeof(struct columnHeader),1,out[14]);
            }
            strcpy(tmp.d_lastdayinmonthfl,data);
            fwrite(&(tmp.d_lastdayinmonthfl),sizeof(tmp.d_lastdayinmonthfl), 1, out[14]);
            break;
           case 15:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 1;
              fwrite(&header,sizeof(struct columnHeader),1,out[15]);
            }
            strcpy(tmp.d_holidayfl,data);
            fwrite(&(tmp.d_holidayfl),sizeof(tmp.d_holidayfl), 1, out[15]);
            break;
           case 16:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 1;
              fwrite(&header,sizeof(struct columnHeader),1,out[16]);
            }
            strcpy(tmp.d_weekdayfl,data);
            fwrite(&(tmp.d_weekdayfl),sizeof(tmp.d_weekdayfl), 1, out[16]);
            break;
        }
        count++;
      }
    }
    if(count == 16){
      if(writeHeader == 1){
        header.blockSize = header.tupleNum * 1;
        fwrite(&header,sizeof(struct columnHeader),1,out[16]);
      }
      strncpy(tmp.d_weekdayfl,buf+prev,i-prev);
      fwrite(&(tmp.d_weekdayfl),sizeof(tmp.d_weekdayfl), 1, out[16]);
    }
  }

  for(i=0;i<17;i++){
    fclose(out[i]);
  }

}

void lineorder (FILE *fp, char *outName){
  struct lineorder tmp;
  char data [1024] = {0};
  char buf[1024] = {0};
  int count = 0, i = 0,prev = 0;
  long tupleCount =0, tupleRemain = 0, tupleUnit = 0;
  FILE * out[17];

  for(i=0;i<17;i++){
    char path[PATH_MAX] = {0};
    sprintf(path,"%s%d",outName,i);
    out[i] = fopen(path, "w");
    if(!out[i]){
      printf("Failed to open %s\n",path);
      exit(-1);
    }
  }

  struct columnHeader header;
  long tupleNum = 0;
  while(fgets(buf,sizeof(buf),fp) !=NULL)
    tupleNum ++;

  header.totalTupleNum = tupleNum;
  tupleRemain = tupleNum;
  if(tupleNum > BLOCKNUM)
    tupleUnit = BLOCKNUM;
  else
    tupleUnit = tupleNum;
  header.tupleNum = tupleUnit;
  header.format = UNCOMPRESSED;
  header.blockId = 0;
  header.blockTotal = (tupleNum + BLOCKNUM -1) / BLOCKNUM ;
  fseek(fp,0,SEEK_SET);
/*  header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[0]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[1]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[2]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[3]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[4]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[5]);*/
  /*header.blockSize = header.tupleNum * 16;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[6]);*/
  /*header.blockSize = header.tupleNum * 1;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[7]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[8]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[9]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[10]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[11]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[12]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[13]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[14]);*/
  /*header.blockSize = header.tupleNum * sizeof(int);*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[15]);*/
  /*header.blockSize = header.tupleNum * 10;*/
  /*fwrite(&header, sizeof(struct columnHeader), 1, out[16]);*/
  while(fgets(buf,sizeof(buf),fp)!= NULL){
    int writeHeader = 0;
    tupleCount ++;
    if(tupleCount > BLOCKNUM){
      tupleCount = 1;
      tupleRemain -= BLOCKNUM;
      if (tupleRemain > BLOCKNUM)
        tupleUnit = BLOCKNUM;
      else
        tupleUnit = tupleRemain;
      header.tupleNum = tupleUnit;
      header.blockId ++;
      writeHeader = 1;
    }
    for(i = 0, prev = 0,count=0; buf[i] !='\n';i++){
      if (buf[i] == delimiter){
        memset(data,0,sizeof(data));
        strncpy(data,buf+prev,i-prev);
        prev = i+1;
        switch(count){
           case 0:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[0]);
            }
            tmp.lo_orderkey = strtol(data,NULL,10);
            fwrite(&(tmp.lo_orderkey),sizeof(int),1,out[0]);
            break;
           case 1:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[1]);
            }
            tmp.lo_linenumber = strtol(data,NULL,10);
            fwrite(&(tmp.lo_linenumber),sizeof(int),1,out[1]);
            break;
           case 2:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[2]);
            }
            tmp.lo_custkey = strtol(data,NULL,10);
            fwrite(&(tmp.lo_custkey),sizeof(int),1,out[2]);
            break;
           case 3:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[3]);
            }
            tmp.lo_partkey = strtol(data,NULL,10);
            fwrite(&(tmp.lo_partkey),sizeof(int),1,out[3]);
            break;
           case 4:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[4]);
            }
            tmp.lo_suppkey = strtol(data,NULL,10);
            fwrite(&(tmp.lo_suppkey),sizeof(int),1,out[4]);
            break;
           case 5:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[5]);
            }
            tmp.lo_orderdate = strtol(data,NULL,10);
            fwrite(&(tmp.lo_orderdate),sizeof(int),1,out[5]);
            break;
           case 6:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 16;
              fwrite(&header,sizeof(struct columnHeader),1,out[6]);
            }
            strcpy(tmp.lo_orderpriority,data);
            fwrite(&(tmp.lo_orderpriority),sizeof(tmp.lo_orderpriority), 1, out[6]);
            break;
           case 7:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 1;
              fwrite(&header,sizeof(struct columnHeader),1,out[7]);
            }
            strcpy(tmp.lo_shippriority,data);
            fwrite(&(tmp.lo_shippriority),sizeof(tmp.lo_shippriority), 1, out[7]);
            break;
           case 8:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[8]);
            }
            tmp.lo_quantity = strtol(data,NULL,10);
            fwrite(&(tmp.lo_quantity),sizeof(int),1,out[8]);
            break;
           case 9:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[9]);
            }
            tmp.lo_extendedprice = strtol(data,NULL,10);
            fwrite(&(tmp.lo_extendedprice),sizeof(int),1,out[9]);
            break;
           case 10:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[10]);
            }
            tmp.lo_ordtotalprice = strtol(data,NULL,10);
            fwrite(&(tmp.lo_ordtotalprice),sizeof(int),1,out[10]);
            break;
           case 11:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[11]);
            }
            tmp.lo_discount = strtol(data,NULL,10);
            fwrite(&(tmp.lo_discount),sizeof(int),1,out[11]);
            break;
           case 12:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[12]);
            }
            tmp.lo_revenue = strtol(data,NULL,10);
            fwrite(&(tmp.lo_revenue),sizeof(int),1,out[12]);
            break;
           case 13:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[13]);
            }
            tmp.lo_supplycost = strtol(data,NULL,10);
            fwrite(&(tmp.lo_supplycost),sizeof(int),1,out[13]);
            break;
           case 14:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[14]);
            }
            tmp.lo_tax = strtol(data,NULL,10);
            fwrite(&(tmp.lo_tax),sizeof(int),1,out[14]);
            break;
           case 15:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * sizeof(int);
              fwrite(&header,sizeof(struct columnHeader),1,out[15]);
            }
            tmp.lo_commitdate = strtol(data,NULL,10);
            fwrite(&(tmp.lo_commitdate),sizeof(int),1,out[15]);
            break;
           case 16:
            if(writeHeader == 1){
              header.blockSize = header.tupleNum * 10;
              fwrite(&header,sizeof(struct columnHeader),1,out[16]);
            }
            strcpy(tmp.lo_shipmode,data);
            fwrite(&(tmp.lo_shipmode),sizeof(tmp.lo_shipmode), 1, out[16]);
            break;
        }
        count++;
      }
    }
    if(count == 16){
      if(writeHeader == 1){
        header.blockSize = header.tupleNum * 10;
        fwrite(&header,sizeof(struct columnHeader),1,out[16]);
      }
      strncpy(tmp.lo_shipmode,buf+prev,i-prev);
      fwrite(&(tmp.lo_shipmode),sizeof(tmp.lo_shipmode), 1, out[16]);
    }
  }

  for(i=0;i<17;i++){
    fclose(out[i]);
  }

}

int main(int argc, char ** argv){
  FILE * in = NULL, *out = NULL;
  int table;
  int setPath = 0;
  char path[PATH_MAX];
  char cwd[PATH_MAX];

  int long_index;
  struct option long_options[] = {
    {"supplier",required_argument,0,'0'},
    {"customer",required_argument,0,'1'},
    {"part",required_argument,0,'2'},
    {"ddate",required_argument,0,'3'},
    {"lineorder",required_argument,0,'4'},
    {"delimiter",required_argument,0,'5'},
    {"datadir",required_argument,0,'6'}
  };

  while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
    switch(table){
      case '6':
        setPath = 1;
        strcpy(path,optarg);
        break;
    }
  }

  optind=1;

  getcwd(cwd,PATH_MAX);
  while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
    switch(table){
      case '0':
        in = fopen(optarg,"r");
        if(!in){
          printf("Failed to open %s\n",optarg);
          exit(-1);
        }
        if (setPath == 1){
          chdir(path);
        }
        supplier(in,"SUPPLIER");
        if (setPath == 1){
          chdir(cwd);
        }
        fclose(in);
        break;
      case '1':
        in = fopen(optarg,"r");
        if(!in){
          printf("Failed to open %s\n",optarg);
          exit(-1);
        }
        if (setPath == 1){
          chdir(path);
        }
        customer(in,"CUSTOMER");
        if (setPath == 1){
          chdir(cwd);
        }
        fclose(in);
        break;
      case '2':
        in = fopen(optarg,"r");
        if(!in){
          printf("Failed to open %s\n",optarg);
          exit(-1);
        }
        if (setPath == 1){
          chdir(path);
        }
        part(in,"PART");
        if (setPath == 1){
          chdir(cwd);
        }
        fclose(in);
        break;
      case '3':
        in = fopen(optarg,"r");
        if(!in){
          printf("Failed to open %s\n",optarg);
          exit(-1);
        }
        if (setPath == 1){
          chdir(path);
        }
        ddate(in,"DDATE");
        if (setPath == 1){
          chdir(cwd);
        }
        fclose(in);
        break;
      case '4':
        in = fopen(optarg,"r");
        if(!in){
          printf("Failed to open %s\n",optarg);
          exit(-1);
        }
        if (setPath == 1){
          chdir(path);
        }
        lineorder(in,"LINEORDER");
        if (setPath == 1){
          chdir(cwd);
        }
        fclose(in);
        break;
      case '5':
        delimiter = optarg[0];
        break;
    }
  }

  return 0;
}

